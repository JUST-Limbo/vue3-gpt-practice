export default [
  "防抖（debounce）函数是一种常用的优化手段，它可以确保在一段连续的时间内，某个函数只执行一次。这在处理一些高频触发的事件（如：滚动、输入、窗口大小改变等）时非常有用，可以提高程序的性能。\n\n以下是一个使用 JavaScript 实现的简单防抖函数：\n\n\n```javascript\nfunction debounce(func, wait) {\n  let timeout;\n  return function(...args) {\n    const context = this;\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      func.apply(context, args);\n    }, wait);\n  };\n}\n```\n在这个防抖函数中，`func` 是需要被防抖的函数，`wait` 是等待时间（毫秒）。函数返回一个新的函数，这个新函数在被连续调用时，会取消之前的调用，并重新计时。只有当等待时间 `wait` 过后，且没有新的调用时，才会执行 `func` 函数。\n\n使用示例：\n\n\n```javascript\n// 假设我们有一个需要防抖的函数 handleScroll\nfunction handleScroll() {\n  console.log('Scrolling...');\n}\n\n// 创建一个防抖函数，等待时间为 500 毫秒\nconst debouncedHandleScroll = debounce(handleScroll, 500);\n\n// 假设 scrollEvent 是一个滚动事件，我们可以这样使用防抖函数\nwindow.addEventListener('scroll', debouncedHandleScroll);\n```\n在这个示例中，无论用户多么频繁地滚动页面，`handleScroll` 函数都只会在每次滚动停止后的 500 毫秒内执行一次。",
  "在JavaScript中，节流（Throttling）是一种优化高频率触发的事件或函数调用，使其在一定时间内只执行一次的技术。这在处理滚动、窗口大小调整、鼠标移动等高频事件时非常有用，可以提高性能并减少不必要的计算。\n\n以下是一个简单的节流函数的实现：\n\n\n```javascript\nfunction throttle(func, delay) {\n  let lastCall = 0;\n\n  return function(...args) {\n    const now = new Date().getTime();\n\n    if (now - lastCall < delay) {\n      return;\n    }\n\n    lastCall = now;\n    return func(...args);\n  };\n}\n```\n在这个实现中，`throttle` 函数接受两个参数：要节流的函数 `func` 和两次函数调用之间的最小延迟 `delay`（以毫秒为单位）。它返回一个新的函数，该函数在被调用时会检查自上次调用以来是否已经过去了指定的延迟时间。如果是，则调用原始函数 `func`；如果不是，则忽略此次调用。\n\n你可以这样使用这个函数：\n\n\n```javascript\n// 示例：节流一个滚动事件处理函数\n\nwindow.addEventListener('scroll', throttle(function() {\n  console.log('Scroll event throttled!');\n}, 200));\n```\n在这个示例中，滚动事件处理函数被节流，以便在200毫秒内最多只调用一次。这有助于减少滚动事件处理函数的调用频率，从而提高性能。",
  '在JavaScript中，`setTimeout`的最小延迟理论上应该是0毫秒。然而，实际上，即使你将延迟设置为0，它也不会立即执行。这是因为JavaScript的事件循环和浏览器的工作方式。\n\n当你使用`setTimeout(func, 0)`时，你告诉浏览器：“当你有空的时候，尽快执行这个函数，但现在不要阻塞其他代码。”浏览器会将这个定时器加入到事件队列中，并在当前执行栈清空后的下一个事件循环迭代中处理它。这意味着，即使延迟是0，该函数也会在当前同步代码执行完毕之后，以及任何微任务（microtasks，如Promise回调）处理完之后才会被调用。\n\n此外，HTML5规范规定了`setTimeout`的最小延迟限制，这个限制通常是4毫秒（但这个值可能会因浏览器和硬件的不同而有所变化）。这是为了防止某些旧版本的浏览器在处理高频率定时器时过度消耗CPU资源。因此，即使你设置了一个小于这个限制的延迟，浏览器也会将这个延迟增加到最小延迟限制。\n\n需要注意的是，这个4毫秒的限制是一个建议的最小值，并不所有的浏览器都会严格遵守。而且，随着浏览器和硬件性能的提升，这个限制可能会发生变化。如果你需要精确控制时间，最好使用`requestAnimationFrame`，它专门为动画等需要精确时间控制的任务设计。',
  '**遗失的时光**\n\n在老街的小巷深处，有一家古老的钟表店。店主是一个白发苍苍的老人，他的眼里总是闪烁着对时光无尽的敬畏。\n\n有一天，一个年轻人走进了这家店。他的眼神里充满了迷茫和焦虑。“老人家，我总觉得我的时间不够用。”他叹息道。\n\n老人微笑着，从陈列柜里取出一个沙漏，递给了年轻人：“这是我能给你的唯一建议。每天只翻转这个沙漏一次，让它提醒你珍惜每一刻。”\n\n年轻人将沙漏接在手中，感到有些不解，但还是带着它离开了。\n\n回到家后，他按照老人的建议，每天只翻转沙漏一次。他开始更加专注于当下，无论是工作还是与家人相处。渐渐地，他发现自己的生活变得充实起来，焦虑也减少了。\n\n然而，有一天，他不小心打破了沙漏。时间的沙子洒了一地，他感到一阵恐慌。他急忙跑回钟表店，向老人求救。\n\n“时间是无法挽回的，就像这洒落的沙子。”老人平静地说，“但你可以学会从中汲取教训，更加珍惜现在和未来。”\n\n年轻人恍然大悟。他明白了老人给他沙漏的真正用意。从那以后，他不再抱怨时间不够，而是努力把握每一个当下，让生命变得更加有意义。\n\n而那条老街的小巷里，依然传来钟表店悠扬的钟声，仿佛在提醒着每一个路过的人：珍惜时光，活在当下。'
]
